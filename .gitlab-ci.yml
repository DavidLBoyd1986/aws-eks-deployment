# This file is a template, and might need editing before it works on your project.
# To contribute improvements to CI/CD templates, please follow the Development guide at:
# https://docs.gitlab.com/ee/development/cicd/templates.html
# This specific template is located at:
# https://gitlab.com/gitlab-org/gitlab/-/blob/master/lib/gitlab/ci/templates/Getting-Started.gitlab-ci.yml

# This is a sample GitLab CI/CD configuration file that should run without any modifications.
# It demonstrates a basic 3 stage CI/CD pipeline. Instead of real tests or scripts,
# it uses echo commands to simulate the pipeline execution.
#
# A pipeline is composed of independent jobs that run scripts, grouped into stages.
# Stages run in sequential order, but jobs within stages run in parallel.
#
# For more information, see: https://docs.gitlab.com/ee/ci/yaml/index.html#stages

variables:
  # Deployment specific variables
  CLUSTER_NAME: EKSPrivateCluster
  KUBE_VERSION: "1.32"
  KUBE_NAMESPACE: web-app
  KUBE_LOAD_BALANCER_TYPE: NLB # Must be (NLB || ALB)
  REGION: $AWS_DEFAULT_REGION
  # Required CICD Variables:
  BUCKET_NAME: $BUCKET_NAME
  BASTION_USERNAME: $BASTION_USERNAME
  BASTION_PASSWORD: $BASTION_PASSWORD
  PERSONAL_PUBLIC_IP: $PERSONAL_PUBLIC_IP 
  # Possible Future Additions:
  #IMAGE_REGISTRY: 
  #IMAGE_REPOSITORY:
  #IMAGE_TAG:


stages:    # List of stages and their order of execution
  - deploy_cloudformation


deploy-cloudformation-templates:
  stage: deploy_cloudformation 
  environment: production
  tags:
    - gitlab-runner-docker
  image:
    name: davidboyd1986/aws-kube:latest
  timeout: 30m # The EKS Cluster takes a long time to deploy
  script:

    #--------------------------
    # Replace/Prepare variables
    #--------------------------

    # Get newest version of HELM to be installed in the Linux Bastion Host:
    - |
      HELM_VERSION=$(curl -s https://api.github.com/repos/helm/helm/releases/latest \
        | grep tag_name | cut -d '"' -f 4)
    - echo $HELM_VERSION

    - PUBLIC_IP_RANGE=${PERSONAL_PUBLIC_IP}/32
    - echo $PUBLIC_IP_RANGE

    # Replace variables in the CloudFormation files:
    - sed -i "s|\\\$BUCKET_NAME|${BUCKET_NAME}|g" ./parameters/s3_bucket_parameters.json
    - sed -i "s|\\\$PUBLIC_IP_RANGE|${PUBLIC_IP_RANGE}|g" ./parameters/eks_vpc_parameters.json
    - sed -i "s|\\\$BUCKET_NAME|${BUCKET_NAME}|g" ./parameters/bh_infrastructure_parameters.json
    - sed -i "s|\\\$PUBLIC_IP_RANGE|${PUBLIC_IP_RANGE}|g" ./parameters/bh_infrastructure_parameters.json
    - sed -i "s|\\\$BASTION_USERNAME|${BASTION_USERNAME}|g" ./parameters/bh_infrastructure_parameters.json
    - sed -i "s|\\\$BASTION_PASSWORD|${BASTION_PASSWORD}|g" ./parameters/bh_infrastructure_parameters.json
    - sed -i "s|\\\$CLUSTER_NAME|${CLUSTER_NAME}|g" ./parameters/bh_infrastructure_parameters.json
    - sed -i "s|\\\$KUBE_VERSION|${KUBE_VERSION}|g" ./parameters/bh_infrastructure_parameters.json
    - sed -i "s|\\\$HELM_VERSION|${HELM_VERSION}|g" ./parameters/bh_infrastructure_parameters.json

    # Replace ${KUBE_NAMESPACE} in kubernetes files:
    - sed -i "s|\\\${KUBE_NAMESPACE}|${KUBE_NAMESPACE}|g" ./kubernetes/web-app-deployment.yml
    - sed -i "s|\\\${KUBE_NAMESPACE}|${KUBE_NAMESPACE}|g" ./kubernetes/web-app-nlb.yml
    - sed -i "s|\\\${KUBE_NAMESPACE}|${KUBE_NAMESPACE}|g" ./kubernetes/web-app-service.yml
    - sed -i "s|\\\${KUBE_NAMESPACE}|${KUBE_NAMESPACE}|g" ./kubernetes/web-app-ingress.yml

    # Get AWS ACCOUNT ID 
    - AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

    # Get AMI ID for the aws-eks-optimized AMIs for the region and specific kubernetes version
    - |
      AMI_ID=$(aws ssm get-parameter \
        --name /aws/service/eks/optimized-ami/${KUBE_VERSION}/amazon-linux-2/recommended/image_id \
        --region ${REGION} --query 'Parameter.Value' --output text)

    # Replace the variables ($CLUSTER_NAME) in other files with the actual values:
    - sed -i "s|\\\$CLUSTER_NAME|${CLUSTER_NAME}|g" ./IaC/eks_infrastructure_deployment.yml
    - sed -i "s|\\\$AMI_ID|${AMI_ID}|g" ./IaC/eks_infrastructure_deployment.yml

    # Copy/Compress the required cluster deploy files, compress the directory
    - cp -rp parameters/ IaC/ kubernetes/ eks_deploy_script.sh build_script_deployment/
    - tar -cvf eks_deploy_script.tar build_script_deployment

    # Test the variables were replaced successfully
    - cat ./parameters/s3_bucket_parameters.json
    - cat ./parameters/bh_infrastructure_parameters.json
    - cat ./parameters/eks_vpc_parameters.json

    - echo "Variable preparation is complete."

    #------------------------------------
    # Deploying the CloudFormation Stacks
    #------------------------------------


    # Deploy the S3 Bucket Stack
    - S3_BUCKET_EXISTS=$(aws s3 ls | grep -c $BUCKET_NAME || echo 0)

    - |
      if [ $S3_BUCKET_EXISTS -gt 0 ]; then
        echo "The s3-bucket-stack already exists. Skipping this step....";
      else
        aws cloudformation create-stack --stack-name s3-bucket-stack \
          --template-body file://./IaC/s3_bucket_kube_deployment.yml \
          --parameters file://./parameters/s3_bucket_parameters.json \
          --capabilities CAPABILITY_NAMED_IAM --region $REGION;
      fi

    # TODO - Sleep or add logic to wait for bucket to be created
    - sleep 30

    # Upload the tar file to the S3 bucket
    - aws s3 cp eks_deploy_script.tar s3://${BUCKET_NAME}

    # Deploy the BH VPC Stack
    - |
      aws cloudformation deploy --stack-name bh-vpc-stack \
        --template-file ./IaC/bastion_host_vpc_deployment.yml --region $REGION

    # Deploy the EKS VPC Stack
    - |
      EKS_VPC_EXISTS=$(aws cloudformation list-stacks \
        --stack-status-filter CREATE_COMPLETE --region $REGION \
        2> /dev/null | grep -c eks-vpc-stack || echo 0)

    - |
      if [ $EKS_VPC_EXISTS -gt 0 ]; then
        echo "The eks-vpc-stack already exists. Skipping this step....";
      else
        echo "Creating the eks-vpc-stack";
        aws cloudformation create-stack --stack-name eks-vpc-stack \
          --template-body file://./IaC/eks_vpc_deployment.yml \
          --parameters file://./parameters/eks_vpc_parameters.json \
          --capabilities CAPABILITY_NAMED_IAM --region $REGION;
      fi

    # Deploy the BH IAM stack
    - |
      aws cloudformation deploy --stack-name bh-iam-stack \
        --template-file ./IaC/bastion_host_iam_deployment.yml \
        --capabilities CAPABILITY_IAM --region $REGION
    # Deploy the EKS IAM stack
    - |
      aws cloudformation deploy --stack-name eks-iam-stack \
        --template-file ./IaC/eks_iam_deployment.yml \
        --capabilities CAPABILITY_NAMED_IAM --region $REGION
    # Deploy Transit Gateway so Bastion Hosts can connect to EKS Cluster
    - |
      aws cloudformation deploy --stack-name eks-bh-vpc-transit-gateway-stack \
      --template-file ./IaC/transit_gateway_deployment.yml --region $REGION

    # Update Bastion Host Route Tables with routes to the transit gateway
    - |
      TRANSIT_GATEWAY_ID=$(aws ec2 describe-transit-gateways --region $REGION \
        --query 'TransitGateways[*]' --output json | \
        jq -r '.[] | select(.Description == "BH-EKS-VPC-TransitGateway") | .TransitGatewayId')

    # Get Bastion Host VPC ID, and update it's route tables:
    - |
      BH_VPC_ID=$(aws ec2 describe-vpcs --region $REGION \
        --filters "Name=cidr,Values=192.168.2.0/24" \
        --query "Vpcs[*].VpcId" --output text)
      echo $BH_VPC_ID
    - |
      BH_ROUTE_TABLE_IDS=$(aws ec2 describe-route-tables \
        --region "$REGION" \
        --filters "Name=vpc-id,Values=$BH_VPC_ID" \
        --query 'RouteTables[*].RouteTableId' \
        --output text)
      echo $BH_ROUTE_TABLE_IDS
    - |
      for RT_ID in $BH_ROUTE_TABLE_IDS; do
        echo "Adding route to $RT_ID..."
        aws ec2 create-route \
          --route-table-id "$RT_ID" \
          --destination-cidr-block "192.168.1.0/24" \
          --transit-gateway-id "$TRANSIT_GATEWAY_ID" \
          --region "$REGION"
      done

    # Get EKS VPC ID, and update it's route tables:
    - |
      EKS_VPC_ID=$(aws ec2 describe-vpcs --region $REGION \
        --filters "Name=cidr,Values=192.168.1.0/24" \
        --query "Vpcs[*].VpcId" --output text)
      echo $EKS_VPC_ID
    - |
      EKS_ROUTE_TABLE_IDS=$(aws ec2 describe-route-tables \
        --region "$REGION" \
        --filters "Name=vpc-id,Values=$EKS_VPC_ID" \
        --query 'RouteTables[*].RouteTableId' \
        --output text)
      echo $EKS_ROUTE_TABLE_IDS
    - |
      for RT_ID in $EKS_ROUTE_TABLE_IDS; do
        echo "Adding route to $RT_ID..."
        aws ec2 create-route \
          --route-table-id "$RT_ID" \
          --destination-cidr-block "192.168.2.0/24" \
          --transit-gateway-id "$TRANSIT_GATEWAY_ID" \
          --region "$REGION"
      done


    # Deploy the BH Infrastructure Stack
    - |
      BH_INFRA_EXISTS=$(aws cloudformation list-stacks \
        --stack-status-filter CREATE_COMPLETE | \
        grep -c bh-infrastructure-stack || echo 0)

    - |
      if [ "$BH_INFRA_EXISTS" -gt 0 ]; then
        echo "The bh-infrastructure-stack already exists. Skipping this step....";
      else
        echo "Creating the bh-infrastructure-stack";
        aws cloudformation create-stack --stack-name bh-infrastructure-stack \
          --template-body file://./IaC/bastion_host_infrastructure_deployment.yml \
          --parameters file://./parameters/bh_infrastructure_parameters.json \
          --capabilities CAPABILITY_NAMED_IAM --region $REGION
      fi

    - echo "CloudFormation deployment is complete."

    - echo "Rest Deployment happens from the Linux Bastion Host!"

